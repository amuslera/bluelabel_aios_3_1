"""
Apollo - Simple Backend Agent
Handles API creation, database design, backend logic
"""
import json
from pathlib import Path
from typing import Dict, Any
from .base_agent import SimpleAgent

class ApolloSimple(SimpleAgent):
    """Simplified Apollo for backend development tasks."""
    
    def __init__(self, workspace_dir: str = "workspace"):
        super().__init__("Apollo", "Backend Developer", workspace_dir)
        self.code_dir = self.workspace / "code" / "backend"
        self.code_dir.mkdir(parents=True, exist_ok=True)
    
    def process_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Process backend development tasks."""
        task_type = task.get("type", "")
        
        if task_type == "create_api":
            return self.create_api(task)
        elif task_type == "design_database":
            return self.design_database(task)
        elif task_type == "implement_logic":
            return self.implement_backend_logic(task)
        else:
            # Generic backend task
            return self.handle_generic_backend_task(task)
    
    def create_api(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Create a simple API endpoint."""
        api_name = task.get("api_name", "example_api")
        
        # Simulate thinking about the API
        thought = self.think(f"Creating API endpoint for {api_name}")
        
        # Generate simple FastAPI code
        api_code = f'''"""
{api_name} API endpoint
Generated by Apollo (Simple Agent Experiment)
"""
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class {api_name.title()}Request(BaseModel):
    data: str
    optional_field: Optional[str] = None

class {api_name.title()}Response(BaseModel):
    success: bool
    message: str
    result: Optional[Any] = None

@app.post("/{api_name}")
async def {api_name}_endpoint(request: {api_name.title()}Request) -> {api_name.title()}Response:
    try:
        # Process the request
        result = process_{api_name}(request.data)
        
        return {api_name.title()}Response(
            success=True,
            message="Request processed successfully",
            result=result
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def process_{api_name}(data: str) -> str:
    """Process the {api_name} request."""
    # TODO: Implement actual logic
    return f"Processed: {{data}}"
'''
        
        # Save the code
        api_file = self.code_dir / f"{api_name}_api.py"
        api_file.write_text(api_code)
        
        # Update conversation state
        self.conversation_state.append({
            "agent": "Apollo",
            "action": "created_api",
            "file": str(api_file),
            "thought": thought
        })
        
        return {
            "status": "completed",
            "output": f"Created API endpoint: {api_name}",
            "files_created": [str(api_file)],
            "next_steps": ["Add authentication", "Write tests", "Document API"]
        }
    
    def design_database(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Design database schema."""
        entities = task.get("entities", ["User", "Item"])
        
        # Generate simple SQLAlchemy models
        models_code = '''"""
Database models
Generated by Apollo (Simple Agent Experiment)
"""
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime

Base = declarative_base()
'''
        
        for entity in entities:
            models_code += f'''
class {entity}(Base):
    __tablename__ = '{entity.lower()}s'
    
    id = Column(Integer, primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # TODO: Add entity-specific fields
    
    def __repr__(self):
        return f"<{entity}(id={{self.id}})>"
'''
        
        # Save models
        models_file = self.code_dir / "models.py"
        models_file.write_text(models_code)
        
        return {
            "status": "completed",
            "output": f"Designed database schema with entities: {entities}",
            "files_created": [str(models_file)]
        }
    
    def implement_backend_logic(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Implement backend business logic."""
        logic_description = task.get("description", "business logic")
        
        # Check if we need frontend help
        if "user interface" in logic_description.lower() or "frontend" in logic_description.lower():
            # Hand off to Aphrodite
            handoff_context = {
                "reason": "Task requires frontend implementation",
                "backend_status": "Ready to integrate with frontend",
                "api_endpoints": ["GET /api/data", "POST /api/data"],
                "original_task": task
            }
            
            handoff_msg = self.handoff_to("Aphrodite", handoff_context)
            
            return {
                "status": "handoff",
                "output": "Backend ready, handing off to Aphrodite for frontend",
                "handoff_message": handoff_msg
            }
        
        # Otherwise, implement backend logic
        service_code = f'''"""
Business logic implementation
Generated by Apollo (Simple Agent Experiment)
"""

class {task.get("service_name", "Business")}Service:
    """Service layer for {logic_description}."""
    
    def __init__(self):
        # Initialize service
        pass
    
    def process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Main processing logic."""
        # TODO: Implement actual business logic
        result = {{
            "processed": True,
            "data": data,
            "timestamp": datetime.now().isoformat()
        }}
        return result
'''
        
        service_file = self.code_dir / "services.py"
        service_file.write_text(service_code)
        
        return {
            "status": "completed",
            "output": f"Implemented backend logic for: {logic_description}",
            "files_created": [str(service_file)]
        }
    
    def handle_generic_backend_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Handle any generic backend task."""
        description = task.get("description", "unknown task")
        
        # Simulate work
        thought = self.think(f"Working on backend task: {description}")
        
        # Create a simple output file
        output_file = self.code_dir / f"backend_task_{task.get('id', 'unknown')}.txt"
        output_file.write_text(f"Apollo completed: {description}\n\nThought process: {thought}")
        
        return {
            "status": "completed",
            "output": f"Completed backend task: {description}",
            "files_created": [str(output_file)],
            "thought": thought
        }