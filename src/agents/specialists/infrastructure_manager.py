"""
Infrastructure as Code Management for Jordan Kim

Handles infrastructure provisioning, configuration, and management using
Terraform, CloudFormation, Ansible, and other IaC tools.
"""

import json
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field


@dataclass
class InfrastructureSpec:
    """Specification for infrastructure requirements"""
    project_name: str
    environment: str  # 'dev', 'staging', 'prod'
    cloud_provider: str  # 'aws', 'gcp', 'azure', 'hybrid'
    region: str
    
    # Compute requirements
    compute_type: str = 'kubernetes'  # 'kubernetes', 'ecs', 'vm', 'serverless'
    min_nodes: int = 1
    max_nodes: int = 3
    instance_type: str = 't3.medium'
    
    # Database requirements
    database_type: Optional[str] = None  # 'postgres', 'mysql', 'mongodb', 'redis'
    database_size: str = 'small'  # 'small', 'medium', 'large'
    database_ha: bool = False
    
    # Storage requirements
    storage_type: Optional[str] = None  # 's3', 'efs', 'disk'
    storage_size_gb: int = 100
    
    # Networking
    vpc_cidr: str = '10.0.0.0/16'
    public_subnets: int = 2
    private_subnets: int = 2
    enable_nat: bool = True
    
    # Security
    enable_encryption: bool = True
    enable_backup: bool = True
    backup_retention_days: int = 7
    
    # Monitoring
    enable_monitoring: bool = True
    enable_logging: bool = True
    
    # Cost optimization
    use_spot_instances: bool = False
    enable_auto_scaling: bool = True


class InfrastructureManager:
    """Manages infrastructure as code generation and deployment"""
    
    def __init__(self):
        self.supported_providers = ['aws', 'gcp', 'azure']
        self.supported_tools = ['terraform', 'cloudformation', 'ansible', 'pulumi']
        
    def generate_infrastructure(self, spec: InfrastructureSpec) -> Dict[str, str]:
        """Generate complete infrastructure configuration"""
        configs = {}
        
        # Main Terraform configuration
        configs['terraform/main.tf'] = self._generate_main_tf(spec)
        configs['terraform/variables.tf'] = self._generate_variables_tf(spec)
        configs['terraform/outputs.tf'] = self._generate_outputs_tf(spec)
        
        # Provider-specific modules
        if spec.cloud_provider == 'aws':
            configs.update(self._generate_aws_infrastructure(spec))
        elif spec.cloud_provider == 'gcp':
            configs.update(self._generate_gcp_infrastructure(spec))
        elif spec.cloud_provider == 'azure':
            configs.update(self._generate_azure_infrastructure(spec))
            
        # Kubernetes configurations if needed
        if spec.compute_type == 'kubernetes':
            configs.update(self._generate_k8s_configs(spec))
            
        # Ansible playbooks for configuration management
        configs.update(self._generate_ansible_playbooks(spec))
        
        # Documentation
        configs['terraform/README.md'] = self._generate_infrastructure_docs(spec)
        
        return configs
        
    def _generate_main_tf(self, spec: InfrastructureSpec) -> str:
        """Generate main Terraform configuration"""
        return f"""# Main Terraform Configuration
# Project: {spec.project_name}
# Environment: {spec.environment}
# Generated by Jordan Kim - DevOps Engineer

terraform {{
  required_version = ">= 1.5.0"
  
  required_providers {{
    {self._get_provider_block(spec.cloud_provider)}
  }}
  
  backend "s3" {{
    bucket = "{spec.project_name}-terraform-state"
    key    = "{spec.environment}/terraform.tfstate"
    region = "{spec.region}"
    encrypt = true
    dynamodb_table = "{spec.project_name}-terraform-lock"
  }}
}}

# Provider configuration
{self._get_provider_config(spec)}

# Data sources
{self._get_data_sources(spec)}

# Networking module
module "networking" {{
  source = "./modules/networking"
  
  project_name = var.project_name
  environment  = var.environment
  vpc_cidr     = var.vpc_cidr
  
  public_subnet_count  = {spec.public_subnets}
  private_subnet_count = {spec.private_subnets}
  enable_nat_gateway   = {str(spec.enable_nat).lower()}
  
  tags = local.common_tags
}}

# Compute module
module "compute" {{
  source = "./modules/compute"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id     = module.networking.vpc_id
  subnet_ids = module.networking.private_subnet_ids
  
  compute_type   = "{spec.compute_type}"
  min_size       = {spec.min_nodes}
  max_size       = {spec.max_nodes}
  instance_type  = "{spec.instance_type}"
  
  enable_auto_scaling = {str(spec.enable_auto_scaling).lower()}
  use_spot_instances  = {str(spec.use_spot_instances).lower()}
  
  tags = local.common_tags
}}

{self._generate_database_module(spec) if spec.database_type else ''}

{self._generate_storage_module(spec) if spec.storage_type else ''}

# Security module
module "security" {{
  source = "./modules/security"
  
  project_name = var.project_name
  environment  = var.environment
  vpc_id       = module.networking.vpc_id
  
  enable_encryption = {str(spec.enable_encryption).lower()}
  
  tags = local.common_tags
}}

# Monitoring module
module "monitoring" {{
  source = "./modules/monitoring"
  
  project_name = var.project_name
  environment  = var.environment
  
  enable_monitoring = {str(spec.enable_monitoring).lower()}
  enable_logging    = {str(spec.enable_logging).lower()}
  
  tags = local.common_tags
}}

# Local variables
locals {{
  common_tags = {{
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
    CreatedBy   = "Jordan Kim"
  }}
}}
"""

    def _generate_variables_tf(self, spec: InfrastructureSpec) -> str:
        """Generate Terraform variables file"""
        return f"""# Terraform Variables
# Generated by Jordan Kim - DevOps Engineer

variable "project_name" {{
  description = "Name of the project"
  type        = string
  default     = "{spec.project_name}"
}}

variable "environment" {{
  description = "Environment name"
  type        = string
  default     = "{spec.environment}"
  
  validation {{
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }}
}}

variable "region" {{
  description = "Cloud provider region"
  type        = string
  default     = "{spec.region}"
}}

variable "vpc_cidr" {{
  description = "CIDR block for VPC"
  type        = string
  default     = "{spec.vpc_cidr}"
}}

variable "instance_type" {{
  description = "Instance type for compute resources"
  type        = string
  default     = "{spec.instance_type}"
}}

variable "min_size" {{
  description = "Minimum number of instances"
  type        = number
  default     = {spec.min_nodes}
}}

variable "max_size" {{
  description = "Maximum number of instances"
  type        = number
  default     = {spec.max_nodes}
}}

variable "database_instance_class" {{
  description = "Database instance class"
  type        = string
  default     = "{self._get_db_instance_class(spec)}"
}}

variable "backup_retention_days" {{
  description = "Number of days to retain backups"
  type        = number
  default     = {spec.backup_retention_days}
}}

variable "enable_deletion_protection" {{
  description = "Enable deletion protection for production resources"
  type        = bool
  default     = {str(spec.environment == 'prod').lower()}
}}
"""

    def _generate_outputs_tf(self, spec: InfrastructureSpec) -> str:
        """Generate Terraform outputs file"""
        return f"""# Terraform Outputs
# Generated by Jordan Kim - DevOps Engineer

output "vpc_id" {{
  description = "ID of the VPC"
  value       = module.networking.vpc_id
}}

output "private_subnet_ids" {{
  description = "IDs of private subnets"
  value       = module.networking.private_subnet_ids
}}

output "public_subnet_ids" {{
  description = "IDs of public subnets"
  value       = module.networking.public_subnet_ids
}}

{self._get_compute_outputs(spec)}

{self._get_database_outputs(spec) if spec.database_type else ''}

output "load_balancer_endpoint" {{
  description = "Endpoint of the load balancer"
  value       = module.compute.load_balancer_endpoint
}}

output "monitoring_dashboard_url" {{
  description = "URL for monitoring dashboard"
  value       = module.monitoring.dashboard_url
}}

output "estimated_monthly_cost" {{
  description = "Estimated monthly cost"
  value       = "${{
    {self._estimate_monthly_cost(spec)}
  }}"
}}
"""

    def _generate_aws_infrastructure(self, spec: InfrastructureSpec) -> Dict[str, str]:
        """Generate AWS-specific infrastructure modules"""
        modules = {}
        
        # Networking module
        modules['terraform/modules/networking/main.tf'] = self._generate_aws_networking(spec)
        modules['terraform/modules/networking/variables.tf'] = self._generate_module_variables('networking')
        modules['terraform/modules/networking/outputs.tf'] = self._generate_module_outputs('networking')
        
        # Compute module
        if spec.compute_type == 'kubernetes':
            modules['terraform/modules/compute/main.tf'] = self._generate_eks_cluster(spec)
        elif spec.compute_type == 'ecs':
            modules['terraform/modules/compute/main.tf'] = self._generate_ecs_cluster(spec)
        else:
            modules['terraform/modules/compute/main.tf'] = self._generate_ec2_instances(spec)
            
        # Security module
        modules['terraform/modules/security/main.tf'] = self._generate_security_groups(spec)
        
        # Monitoring module
        modules['terraform/modules/monitoring/main.tf'] = self._generate_cloudwatch_config(spec)
        
        return modules
        
    def _generate_eks_cluster(self, spec: InfrastructureSpec) -> str:
        """Generate EKS cluster configuration"""
        return f"""# EKS Cluster Configuration
# Generated by Jordan Kim - DevOps Engineer

module "eks" {{
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = "${{var.project_name}}-${{var.environment}}"
  cluster_version = "1.28"

  vpc_id     = var.vpc_id
  subnet_ids = var.subnet_ids

  # Cluster endpoint access
  cluster_endpoint_public_access  = true
  cluster_endpoint_private_access = true

  # Add-ons
  cluster_addons = {{
    coredns = {{
      most_recent = true
    }}
    kube-proxy = {{
      most_recent = true
    }}
    vpc-cni = {{
      most_recent = true
    }}
    aws-ebs-csi-driver = {{
      most_recent = true
    }}
  }}

  # Node groups
  eks_managed_node_groups = {{
    main = {{
      name = "${{var.project_name}}-${{var.environment}}-main"

      instance_types = [var.instance_type]
      
      min_size     = var.min_size
      max_size     = var.max_size
      desired_size = var.min_size

      disk_size = 50
      
      # Use spot instances if enabled
      capacity_type = var.use_spot_instances ? "SPOT" : "ON_DEMAND"
      
      update_config = {{
        max_unavailable_percentage = 33
      }}

      labels = {{
        Environment = var.environment
        NodeGroup   = "main"
      }}

      tags = merge(
        var.tags,
        {{
          "k8s.io/cluster-autoscaler/enabled" = "true"
          "k8s.io/cluster-autoscaler/${{var.project_name}}-${{var.environment}}" = "owned"
        }}
      )
    }}
  }}

  # Security group rules
  node_security_group_additional_rules = {{
    ingress_self_all = {{
      description = "Node to node all ports/protocols"
      protocol    = "-1"
      from_port   = 0
      to_port     = 0
      type        = "ingress"
      self        = true
    }}
    
    egress_all = {{
      description      = "Node all egress"
      protocol         = "-1"
      from_port        = 0
      to_port          = 0
      type             = "egress"
      cidr_blocks      = ["0.0.0.0/0"]
      ipv6_cidr_blocks = ["::/0"]
    }}
  }}

  tags = var.tags
}}

# Install cluster autoscaler
resource "helm_release" "cluster_autoscaler" {{
  name       = "cluster-autoscaler"
  repository = "https://kubernetes.github.io/autoscaler"
  chart      = "cluster-autoscaler"
  namespace  = "kube-system"

  values = [
    yamlencode({{
      autoDiscovery = {{
        clusterName = module.eks.cluster_name
      }}
      awsRegion = data.aws_region.current.name
      rbac = {{
        serviceAccount = {{
          annotations = {{
            "eks.amazonaws.com/role-arn" = module.eks.cluster_iam_role_arn
          }}
        }}
      }}
    }})
  ]

  depends_on = [module.eks]
}}

# Install metrics server
resource "helm_release" "metrics_server" {{
  name       = "metrics-server"
  repository = "https://kubernetes-sigs.github.io/metrics-server/"
  chart      = "metrics-server"
  namespace  = "kube-system"

  depends_on = [module.eks]
}}

# Output kubeconfig
output "kubeconfig_command" {{
  description = "Command to update kubeconfig"
  value       = "aws eks update-kubeconfig --region ${{data.aws_region.current.name}} --name ${{module.eks.cluster_name}}"
}}
"""

    def _generate_database_module(self, spec: InfrastructureSpec) -> str:
        """Generate database module configuration"""
        if not spec.database_type:
            return ""
            
        return f"""
# Database module
module "database" {{
  source = "./modules/database"
  
  project_name = var.project_name
  environment  = var.environment
  
  vpc_id     = module.networking.vpc_id
  subnet_ids = module.networking.private_subnet_ids
  
  database_type          = "{spec.database_type}"
  instance_class         = var.database_instance_class
  allocated_storage      = {self._get_storage_size(spec)}
  enable_multi_az        = {str(spec.database_ha).lower()}
  backup_retention_days  = var.backup_retention_days
  enable_encryption      = {str(spec.enable_encryption).lower()}
  
  security_group_ids = [module.security.database_security_group_id]
  
  tags = local.common_tags
}}"""

    def _generate_storage_module(self, spec: InfrastructureSpec) -> str:
        """Generate storage module configuration"""
        if not spec.storage_type:
            return ""
            
        return f"""
# Storage module
module "storage" {{
  source = "./modules/storage"
  
  project_name = var.project_name
  environment  = var.environment
  
  storage_type      = "{spec.storage_type}"
  storage_size_gb   = {spec.storage_size_gb}
  enable_encryption = {str(spec.enable_encryption).lower()}
  enable_versioning = true
  
  lifecycle_rules = {{
    transition_to_ia_days      = 30
    transition_to_glacier_days = 90
    expiration_days           = 365
  }}
  
  tags = local.common_tags
}}"""

    def _generate_k8s_configs(self, spec: InfrastructureSpec) -> Dict[str, str]:
        """Generate Kubernetes configuration files"""
        configs = {}
        
        # Namespace
        configs['k8s/namespace.yaml'] = f"""apiVersion: v1
kind: Namespace
metadata:
  name: {spec.project_name}-{spec.environment}
  labels:
    name: {spec.project_name}-{spec.environment}
    environment: {spec.environment}
"""

        # Resource quotas
        configs['k8s/resource-quota.yaml'] = f"""apiVersion: v1
kind: ResourceQuota
metadata:
  name: {spec.project_name}-quota
  namespace: {spec.project_name}-{spec.environment}
spec:
  hard:
    requests.cpu: "{spec.max_nodes * 2}"
    requests.memory: "{spec.max_nodes * 4}Gi"
    persistentvolumeclaims: "10"
    services.loadbalancers: "2"
"""

        # Network policies
        configs['k8s/network-policy.yaml'] = self._generate_network_policy(spec)
        
        # Storage class
        configs['k8s/storage-class.yaml'] = f"""apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: {spec.project_name}-ssd
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp3
  encrypted: "true"
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
"""

        # Monitoring setup
        configs['k8s/monitoring/prometheus-values.yaml'] = self._generate_prometheus_values(spec)
        
        return configs
        
    def _generate_ansible_playbooks(self, spec: InfrastructureSpec) -> Dict[str, str]:
        """Generate Ansible playbooks for configuration management"""
        playbooks = {}
        
        # Main playbook
        playbooks['ansible/site.yml'] = f"""---
# Main Ansible Playbook
# Generated by Jordan Kim - DevOps Engineer

- name: Configure {spec.project_name} infrastructure
  hosts: all
  become: yes
  
  vars:
    project_name: {spec.project_name}
    environment: {spec.environment}
    
  roles:
    - common
    - security
    - monitoring
    - app
"""

        # Common role
        playbooks['ansible/roles/common/tasks/main.yml'] = """---
- name: Update package cache
  package:
    update_cache: yes
    
- name: Install essential packages
  package:
    name:
      - curl
      - wget
      - vim
      - htop
      - iotop
      - git
    state: present
    
- name: Configure timezone
  timezone:
    name: UTC
    
- name: Configure NTP
  service:
    name: ntp
    state: started
    enabled: yes
"""

        # Security role
        playbooks['ansible/roles/security/tasks/main.yml'] = """---
- name: Configure firewall
  ufw:
    rule: allow
    port: "{{ item }}"
    proto: tcp
  with_items:
    - "22"
    - "80"
    - "443"
    
- name: Enable firewall
  ufw:
    state: enabled
    
- name: Configure fail2ban
  template:
    src: jail.local.j2
    dest: /etc/fail2ban/jail.local
  notify: restart fail2ban
    
- name: Disable root login
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: '^PermitRootLogin'
    line: 'PermitRootLogin no'
  notify: restart sshd
"""

        # Inventory
        playbooks['ansible/inventory/hosts.yml'] = f"""all:
  children:
    {spec.environment}:
      hosts:
        # Add your hosts here
      vars:
        ansible_user: ubuntu
        ansible_ssh_private_key_file: ~/.ssh/{spec.project_name}-{spec.environment}.pem
"""

        return playbooks
        
    def _generate_infrastructure_docs(self, spec: InfrastructureSpec) -> str:
        """Generate infrastructure documentation"""
        return f"""# {spec.project_name} Infrastructure

## Overview
This infrastructure is managed by Terraform and configured for the {spec.environment} environment.

## Architecture
- **Cloud Provider**: {spec.cloud_provider}
- **Region**: {spec.region}
- **Compute**: {spec.compute_type}
- **Database**: {spec.database_type or 'None'}
- **Storage**: {spec.storage_type or 'None'}

## Network Architecture
- **VPC CIDR**: {spec.vpc_cidr}
- **Public Subnets**: {spec.public_subnets}
- **Private Subnets**: {spec.private_subnets}
- **NAT Gateway**: {'Enabled' if spec.enable_nat else 'Disabled'}

## Security
- **Encryption**: {'Enabled' if spec.enable_encryption else 'Disabled'}
- **Backup**: {'Enabled' if spec.enable_backup else 'Disabled'}
- **Backup Retention**: {spec.backup_retention_days} days

## Deployment Instructions

### Prerequisites
1. Terraform >= 1.5.0
2. AWS CLI configured
3. kubectl (for Kubernetes deployments)

### Initial Setup
```bash
# Initialize Terraform
cd terraform
terraform init

# Create workspace for environment
terraform workspace new {spec.environment}

# Plan the deployment
terraform plan -out=tfplan

# Apply the configuration
terraform apply tfplan
```

### Accessing the Cluster
{self._get_access_instructions(spec)}

### Monitoring
- **CloudWatch Dashboard**: Check AWS Console
- **Prometheus**: http://<load-balancer>/prometheus
- **Grafana**: http://<load-balancer>/grafana

### Cost Optimization
- Using {'spot instances' if spec.use_spot_instances else 'on-demand instances'}
- Auto-scaling {'enabled' if spec.enable_auto_scaling else 'disabled'}
- Estimated monthly cost: ${self._estimate_monthly_cost(spec)}

### Disaster Recovery
1. Database backups are automated with {spec.backup_retention_days} day retention
2. Infrastructure state is stored in S3 with versioning
3. All data is encrypted at rest

### Maintenance
- Review and update dependencies monthly
- Check for security patches weekly
- Monitor costs and optimize as needed

## Support
For issues or questions, contact the DevOps team.

---
Generated by Jordan Kim - DevOps Engineer
"""

    def _get_provider_block(self, provider: str) -> str:
        """Get provider block for Terraform"""
        blocks = {
            'aws': """aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.11"
    }""",
            'gcp': """google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }""",
            'azure': """azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.23"
    }"""
        }
        return blocks.get(provider, blocks['aws'])

    def _get_provider_config(self, spec: InfrastructureSpec) -> str:
        """Get provider configuration"""
        if spec.cloud_provider == 'aws':
            return f"""provider "aws" {{
  region = var.region
  
  default_tags {{
    tags = local.common_tags
  }}
}}

provider "kubernetes" {{
  host                   = module.compute.cluster_endpoint
  cluster_ca_certificate = base64decode(module.compute.cluster_certificate_authority_data)
  
  exec {{
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    args = ["eks", "get-token", "--cluster-name", module.compute.cluster_name]
  }}
}}"""
        elif spec.cloud_provider == 'gcp':
            return f"""provider "google" {{
  project = var.project_id
  region  = var.region
}}"""
        else:
            return ""

    def _get_data_sources(self, spec: InfrastructureSpec) -> str:
        """Get data sources for Terraform"""
        if spec.cloud_provider == 'aws':
            return """data "aws_availability_zones" "available" {
  state = "available"
}

data "aws_region" "current" {}

data "aws_caller_identity" "current" {}"""
        return ""

    def _get_db_instance_class(self, spec: InfrastructureSpec) -> str:
        """Get database instance class based on size"""
        if spec.cloud_provider == 'aws':
            sizes = {
                'small': 'db.t3.micro',
                'medium': 'db.t3.medium',
                'large': 'db.r6g.large'
            }
        elif spec.cloud_provider == 'gcp':
            sizes = {
                'small': 'db-f1-micro',
                'medium': 'db-n1-standard-1',
                'large': 'db-n1-standard-4'
            }
        else:
            sizes = {'small': 'small', 'medium': 'medium', 'large': 'large'}
            
        return sizes.get(spec.database_size, 'db.t3.micro')

    def _get_storage_size(self, spec: InfrastructureSpec) -> int:
        """Get storage size for database"""
        sizes = {
            'small': 20,
            'medium': 100,
            'large': 500
        }
        return sizes.get(spec.database_size, 20)

    def _estimate_monthly_cost(self, spec: InfrastructureSpec) -> int:
        """Estimate monthly infrastructure cost"""
        # Base compute cost
        instance_costs = {
            't3.micro': 10,
            't3.small': 20,
            't3.medium': 40,
            't3.large': 80,
            't3.xlarge': 160
        }
        
        compute_cost = instance_costs.get(spec.instance_type, 40) * spec.min_nodes
        
        # Spot instance discount
        if spec.use_spot_instances:
            compute_cost *= 0.3
            
        # Database cost
        db_cost = 0
        if spec.database_type:
            db_sizes = {'small': 50, 'medium': 200, 'large': 500}
            db_cost = db_sizes.get(spec.database_size, 50)
            if spec.database_ha:
                db_cost *= 2
                
        # Storage cost
        storage_cost = spec.storage_size_gb * 0.1
        
        # Load balancer
        lb_cost = 20
        
        # Data transfer estimate
        data_cost = 50
        
        # Total
        total = compute_cost + db_cost + storage_cost + lb_cost + data_cost
        
        return int(total)

    def _get_compute_outputs(self, spec: InfrastructureSpec) -> str:
        """Get compute-specific outputs"""
        if spec.compute_type == 'kubernetes':
            return """output "cluster_endpoint" {
  description = "Endpoint for Kubernetes cluster"
  value       = module.compute.cluster_endpoint
}

output "cluster_name" {
  description = "Name of the Kubernetes cluster"
  value       = module.compute.cluster_name
}"""
        else:
            return """output "instance_ips" {
  description = "IP addresses of compute instances"
  value       = module.compute.instance_ips
}"""

    def _get_database_outputs(self, spec: InfrastructureSpec) -> str:
        """Get database-specific outputs"""
        return """output "database_endpoint" {
  description = "Database connection endpoint"
  value       = module.database.endpoint
  sensitive   = true
}

output "database_port" {
  description = "Database port"
  value       = module.database.port
}"""

    def _generate_aws_networking(self, spec: InfrastructureSpec) -> str:
        """Generate AWS networking module"""
        return f"""# AWS Networking Module
# Generated by Jordan Kim - DevOps Engineer

module "vpc" {{
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "${{var.project_name}}-${{var.environment}}-vpc"
  cidr = var.vpc_cidr

  azs             = slice(data.aws_availability_zones.available.names, 0, max(var.public_subnet_count, var.private_subnet_count))
  private_subnets = [for i in range(var.private_subnet_count) : cidrsubnet(var.vpc_cidr, 4, i)]
  public_subnets  = [for i in range(var.public_subnet_count) : cidrsubnet(var.vpc_cidr, 4, i + var.private_subnet_count)]

  enable_nat_gateway = var.enable_nat_gateway
  single_nat_gateway = var.environment != "prod"
  enable_dns_hostnames = true
  enable_dns_support = true

  tags = var.tags
}}

output "vpc_id" {{
  value = module.vpc.vpc_id
}}

output "private_subnet_ids" {{
  value = module.vpc.private_subnets
}}

output "public_subnet_ids" {{
  value = module.vpc.public_subnets
}}"""

    def _generate_security_groups(self, spec: InfrastructureSpec) -> str:
        """Generate security group configurations"""
        return f"""# Security Groups Module
# Generated by Jordan Kim - DevOps Engineer

# Application security group
resource "aws_security_group" "app" {{
  name_prefix = "${{var.project_name}}-${{var.environment}}-app-"
  description = "Security group for application instances"
  vpc_id      = var.vpc_id

  ingress {{
    description = "HTTP from ALB"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    security_groups = [aws_security_group.alb.id]
  }}

  ingress {{
    description = "HTTPS from ALB"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    security_groups = [aws_security_group.alb.id]
  }}

  egress {{
    description = "All outbound traffic"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }}

  tags = merge(var.tags, {{
    Name = "${{var.project_name}}-${{var.environment}}-app-sg"
  }})
}}

# Load balancer security group
resource "aws_security_group" "alb" {{
  name_prefix = "${{var.project_name}}-${{var.environment}}-alb-"
  description = "Security group for application load balancer"
  vpc_id      = var.vpc_id

  ingress {{
    description = "HTTP from internet"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }}

  ingress {{
    description = "HTTPS from internet"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }}

  egress {{
    description = "All outbound traffic"
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }}

  tags = merge(var.tags, {{
    Name = "${{var.project_name}}-${{var.environment}}-alb-sg"
  }})
}}

# Database security group
resource "aws_security_group" "database" {{
  name_prefix = "${{var.project_name}}-${{var.environment}}-db-"
  description = "Security group for RDS database"
  vpc_id      = var.vpc_id

  ingress {{
    description = "Database access from app"
    from_port   = 5432  # PostgreSQL default
    to_port     = 5432
    protocol    = "tcp"
    security_groups = [aws_security_group.app.id]
  }}

  tags = merge(var.tags, {{
    Name = "${{var.project_name}}-${{var.environment}}-db-sg"
  }})
}}

output "app_security_group_id" {{
  value = aws_security_group.app.id
}}

output "database_security_group_id" {{
  value = aws_security_group.database.id
}}"""

    def _generate_cloudwatch_config(self, spec: InfrastructureSpec) -> str:
        """Generate CloudWatch monitoring configuration"""
        return f"""# CloudWatch Monitoring Module
# Generated by Jordan Kim - DevOps Engineer

# CloudWatch Dashboard
resource "aws_cloudwatch_dashboard" "main" {{
  dashboard_name = "${{var.project_name}}-${{var.environment}}"

  dashboard_body = jsonencode({{
    widgets = [
      {{
        type   = "metric"
        x      = 0
        y      = 0
        width  = 12
        height = 6
        properties = {{
          metrics = [
            ["AWS/EC2", "CPUUtilization", {{ stat = "Average" }}],
            [".", ".", {{ stat = "Maximum" }}]
          ]
          view    = "timeSeries"
          stacked = false
          region  = data.aws_region.current.name
          title   = "EC2 CPU Utilization"
          period  = 300
        }}
      }},
      {{
        type   = "metric"
        x      = 12
        y      = 0
        width  = 12
        height = 6
        properties = {{
          metrics = [
            ["AWS/ECS", "MemoryUtilization", {{ stat = "Average" }}],
            [".", "CPUUtilization", {{ stat = "Average" }}]
          ]
          view    = "timeSeries"
          stacked = false
          region  = data.aws_region.current.name
          title   = "Container Metrics"
          period  = 300
        }}
      }}
    ]
  }})
}}

# CloudWatch Alarms
resource "aws_cloudwatch_metric_alarm" "high_cpu" {{
  alarm_name          = "${{var.project_name}}-${{var.environment}}-high-cpu"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "300"
  statistic           = "Average"
  threshold           = "80"
  alarm_description   = "This metric monitors CPU utilization"
  alarm_actions       = [aws_sns_topic.alerts.arn]
}}

# SNS Topic for alerts
resource "aws_sns_topic" "alerts" {{
  name = "${{var.project_name}}-${{var.environment}}-alerts"
}}

output "dashboard_url" {{
  value = "https://console.aws.amazon.com/cloudwatch/home?region=${{data.aws_region.current.name}}#dashboards:name=${{aws_cloudwatch_dashboard.main.dashboard_name}}"
}}"""

    def _generate_network_policy(self, spec: InfrastructureSpec) -> str:
        """Generate Kubernetes network policy"""
        return f"""apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: {spec.project_name}-network-policy
  namespace: {spec.project_name}-{spec.environment}
spec:
  podSelector:
    matchLabels:
      app: {spec.project_name}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: {spec.project_name}-{spec.environment}
    - podSelector:
        matchLabels:
          app: {spec.project_name}
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: {spec.project_name}-database
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    - podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 169.254.169.254/32  # Block metadata service
"""

    def _generate_prometheus_values(self, spec: InfrastructureSpec) -> str:
        """Generate Prometheus Helm values"""
        return f"""# Prometheus Helm Values
# Generated by Jordan Kim - DevOps Engineer

prometheus:
  prometheusSpec:
    retention: 15d
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: {spec.project_name}-ssd
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 50Gi
              
    resources:
      requests:
        memory: 2Gi
        cpu: 1
      limits:
        memory: 4Gi
        cpu: 2

grafana:
  enabled: true
  adminPassword: changeme
  persistence:
    enabled: true
    storageClassName: {spec.project_name}-ssd
    size: 10Gi

alertmanager:
  alertmanagerSpec:
    storage:
      volumeClaimTemplate:
        spec:
          storageClassName: {spec.project_name}-ssd
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 10Gi
"""

    def _generate_module_variables(self, module: str) -> str:
        """Generate module variables file"""
        return f"""# {module.title()} Module Variables
# Generated by Jordan Kim - DevOps Engineer

variable "project_name" {{
  description = "Name of the project"
  type        = string
}}

variable "environment" {{
  description = "Environment name"
  type        = string
}}

variable "vpc_id" {{
  description = "VPC ID"
  type        = string
}}

variable "tags" {{
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {{}}
}}
"""

    def _generate_module_outputs(self, module: str) -> str:
        """Generate module outputs file"""
        return f"""# {module.title()} Module Outputs
# Generated by Jordan Kim - DevOps Engineer

output "id" {{
  description = "ID of the {module} resource"
  value       = try(aws_{module}.main.id, "")
}}
"""

    def _get_access_instructions(self, spec: InfrastructureSpec) -> str:
        """Get cluster access instructions"""
        if spec.compute_type == 'kubernetes' and spec.cloud_provider == 'aws':
            return """```bash
# Update kubeconfig
aws eks update-kubeconfig --region $(terraform output -raw region) --name $(terraform output -raw cluster_name)

# Verify connection
kubectl get nodes
```"""
        else:
            return "See provider-specific documentation for access instructions."

    def _generate_ecs_cluster(self, spec: InfrastructureSpec) -> str:
        """Generate ECS cluster configuration"""
        return f"""# ECS Cluster Configuration
# Generated by Jordan Kim - DevOps Engineer

resource "aws_ecs_cluster" "main" {{
  name = "${{var.project_name}}-${{var.environment}}"
  
  setting {{
    name  = "containerInsights"
    value = "enabled"
  }}
  
  tags = var.tags
}}

# ECS Capacity Provider
resource "aws_ecs_capacity_provider" "main" {{
  name = "${{var.project_name}}-${{var.environment}}-cp"
  
  auto_scaling_group_provider {{
    auto_scaling_group_arn = aws_autoscaling_group.ecs.arn
    
    managed_scaling {{
      maximum_scaling_step_size = 10
      minimum_scaling_step_size = 1
      status                    = "ENABLED"
      target_capacity           = 80
    }}
  }}
}}

# Auto Scaling Group for ECS
resource "aws_autoscaling_group" "ecs" {{
  name_prefix         = "${{var.project_name}}-${{var.environment}}-"
  vpc_zone_identifier = var.subnet_ids
  min_size            = var.min_size
  max_size            = var.max_size
  desired_capacity    = var.min_size
  
  launch_template {{
    id      = aws_launch_template.ecs.id
    version = "$Latest"
  }}
  
  tag {{
    key                 = "Name"
    value               = "${{var.project_name}}-${{var.environment}}-ecs"
    propagate_at_launch = true
  }}
}}

# Launch Template
resource "aws_launch_template" "ecs" {{
  name_prefix   = "${{var.project_name}}-${{var.environment}}-"
  image_id      = data.aws_ami.ecs_optimized.id
  instance_type = var.instance_type
  
  iam_instance_profile {{
    name = aws_iam_instance_profile.ecs.name
  }}
  
  user_data = base64encode(<<-EOF
    #!/bin/bash
    echo ECS_CLUSTER=${{aws_ecs_cluster.main.name}} >> /etc/ecs/ecs.config
  EOF
  )
  
  tag_specifications {{
    resource_type = "instance"
    tags = var.tags
  }}
}}

# Data source for ECS optimized AMI
data "aws_ami" "ecs_optimized" {{
  most_recent = true
  owners      = ["amazon"]
  
  filter {{
    name   = "name"
    values = ["amzn2-ami-ecs-hvm-*-x86_64-ebs"]
  }}
}}

output "cluster_name" {{
  value = aws_ecs_cluster.main.name
}}

output "cluster_arn" {{
  value = aws_ecs_cluster.main.arn
}}"""

    def _generate_ec2_instances(self, spec: InfrastructureSpec) -> str:
        """Generate EC2 instances configuration"""
        return f"""# EC2 Instances Configuration
# Generated by Jordan Kim - DevOps Engineer

# Launch Template
resource "aws_launch_template" "app" {{
  name_prefix   = "${{var.project_name}}-${{var.environment}}-"
  image_id      = data.aws_ami.ubuntu.id
  instance_type = var.instance_type
  
  vpc_security_group_ids = var.security_group_ids
  
  user_data = base64encode(templatefile("${{path.module}}/user-data.sh", {{
    project_name = var.project_name
    environment  = var.environment
  }}))
  
  tag_specifications {{
    resource_type = "instance"
    tags = merge(var.tags, {{
      Name = "${{var.project_name}}-${{var.environment}}-app"
    }})
  }}
}}

# Auto Scaling Group
resource "aws_autoscaling_group" "app" {{
  name_prefix         = "${{var.project_name}}-${{var.environment}}-"
  vpc_zone_identifier = var.subnet_ids
  min_size            = var.min_size
  max_size            = var.max_size
  desired_capacity    = var.min_size
  health_check_type   = "ELB"
  health_check_grace_period = 300
  
  launch_template {{
    id      = aws_launch_template.app.id
    version = "$Latest"
  }}
  
  enabled_metrics = [
    "GroupMinSize",
    "GroupMaxSize",
    "GroupDesiredCapacity",
    "GroupInServiceInstances",
    "GroupTotalInstances"
  ]
  
  tag {{
    key                 = "Name"
    value               = "${{var.project_name}}-${{var.environment}}-app"
    propagate_at_launch = true
  }}
}}

# Data source for Ubuntu AMI
data "aws_ami" "ubuntu" {{
  most_recent = true
  owners      = ["099720109477"]  # Canonical
  
  filter {{
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }}
  
  filter {{
    name   = "virtualization-type"
    values = ["hvm"]
  }}
}}

output "instance_ips" {{
  value = aws_autoscaling_group.app.instances
}}"""